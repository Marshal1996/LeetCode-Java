package dp;

/**
 * 我们知道丑数序列是 1, 2, 3, 4, 5, 6, 8, 9...。
 * <p>
 * 我们所有的丑数都是通过之前的丑数乘以 2, 3, 5 生成的，所以丑数序列可以看成下边的样子。
 * <p>
 * 1, 1×2, 1×3, 2×2, 1×5, 2×3, 2×4, 3×3...。
 * <p>
 * 我们可以把丑数分成三组，用丑数序列分别乘 2, 3, 5 。
 * <p>
 * <p>
 * 乘 2: 1×2, 2×2, 3×2, 4×2, 5×2, 6×2, 8×2,9×2,…
 * 乘 3: 1×3, 2×3, 3×3, 4×3, 5×3, 6×3, 8×3,9×3,…
 * 乘 5: 1×5, 2×5, 3×5, 4×5, 5×5, 6×5, 8×5,9×5,…
 * 我们需要做的就是把上边三组按照顺序合并起来。
 * <p>
 * 合并有序数组的话，可以通过归并排序的思想，利用三个指针，每次找到三组中最小的元素，然后指针后移。
 * <p>
 * 当然，最初我们我们并不知道丑数序列，我们可以一边更新丑数序列，一边使用丑数序列。
 *
 * @author Marshal
 * @date 2021/4/11
 */
public class NthUglyNumber {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i < n; i++) {
            int x = dp[p2] * 2;
            int y = dp[p3] * 3;
            int z = dp[p5] * 5;
            int min = Math.min(x, Math.min(y, z));
            if (min == x) {
                p2++;
            }
            if (min == y) {
                p3++;
            }
            if (min == z) {
                p5++;
            }
            dp[i] = min;
        }
        return dp[n - 1];
    }
}
